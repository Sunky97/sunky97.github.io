---
title:  "[Java] 자바의 구동원리와 JVM"
excerpt: ""

categories:
  - Java
tags:
  - [Interview, jvm, gc]

toc: true
toc_sticky: true
 
date: 2021-04-01
last_modified_at: 2021-04-01
---

# **컴퓨터 파일의 실행원리는?**

컴퓨터는 기본적으로 0과 1만 인식할 수 있다. 따라서 사람이 고급언어로 작성한 문서를 컴퓨터가 이해할 수 있는 문서인 저급언어로 바꾸어주어는 작업을 해야만 컴퓨터가 그 파일을 실행할 수 있다.

<br><br>
# **자바 파일의 실행 원리**

![java1](https://tutorialsinhand.com/readwritedata/Images/javaInternalProcess.JPG)

1. .java 확장자의 소스코드를 작성함.
2. .java 소스파일을 자바 컴파일러를 통해 자바 바이트코드 (.class) 로 컴퍼일함
3. 컴파일된 바이트 코드를 JVM의 클래스 로더에 전달
  - 클래스 로더 세부동작
    1. 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드
    2. 검증(Verifying) : JVM 명세에 명시된 대로 구성이 되어있는지 검사
    3. 준비 : 클래스가 필요로 하는 메모리를 할당. (필드, 메서드,인터페이스 등등)
    4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
    5. 초기화 : 클래스 변수들을 적절한 값으로 초기화한다. (static 필드)
4. JVM의 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM 의 메모리에 올린다. 

5. 실행엔진(Excution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이때, 실행엔진은 두 가지 방식(인터프리터, JIT컴파일러)으로 동작할 수 있다.

<br><br>

# **JVM이란?**

JVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 줄여 부르는 용어이다. (가상머신이란 프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이다.) JVM 의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API 와 함께 실행하는 것이다. 그리고 JVM 은 JAVA와 OS 사이에서 중개자 역할을 수행해여 JAVA가 OS 에 구애받지 않고 재사용을 가능하게 해준다. 그리고 가장 중요한 메모리관리, Garbage collection 을 수행한다. 그리고 JVM 은 스택기반의 가상머신 이다. ARM 아키텍쳐 같은 하드웨어는 레지스터 기반으로 동작하는데 비해 JVM은 스택기반으로 동작한다.

## 왜 JVM 을 알아야 하는가?

한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서는 가상머신의 메모리 구조를 알아야 하기 때문이다.
동일한 기능의 프로그램이더라도 메모리 관리에 따라서 성능이 좌우된다. 또한 메모리 관리가 되지 않는 경우 속도저하 현상이나 튕김 현상 등이 일어날 수 있다.

<br><br>

# **JVM의 구성**

## CLass Loader(클래스 로더)
JVM 내로 클래드(.class)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. Runtime 시에 동적으로 클래스를 로드한다. jar파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들을 메모리에서 삭제한다. (컴파일러 역할) 자는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것이다. 그 역할을 클래스 로더가 수행한다.

## Execution Engine(실행 엔진)

클래스를 실행시키는 역할이다. 클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행엔진에 의해 실행된다. 자바 바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다.그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경한다. 이 때 두개지 방식을 사용하게 된다.

## Interpreter(인터프리터)

바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가진다.

## JIT(Just - In - Time)
인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식. 하나씩 인터프리팅해서 실행하는 것이 아니라 바이트코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리터 방식보다 빠르다. JIT 컴파일러를 사용하는 JVM 들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.

## Garbage collector 

GC를 수행하는 모듈 (스레드)이 있다.

<br>
<br>


![jvm1](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVRZ6k%2FbtqDcw8qekS%2Fvi32KUQkZ19yVZwh9xaze1%2Fimg.png)

▲ 일반프로그램과 JAVA프로그램의 비교

일반 프로그램의 경우는 OS만 거치고 하드웨어로 전달되는데 비해 Java프로그램은 JVM을 한 번 더 거치기 때문에, 그리고 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 가지고 있었으나 바이트코드(컴파일된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT컴파일러와 향상된 최적화 기술의 등장으로 속도의 격차를 많이 줄였다.

일반 프로그램은 OS와 바로 맞붙어 있기 때문에 OS에 종속적이다. 그래서 다른 OS에서 실행시키기 위해서는 프로그램을 그 OS에 맞게 변경해야 한다. 하지만 JAVA프로그램은 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램의 변경없이 실행이 가능하다.